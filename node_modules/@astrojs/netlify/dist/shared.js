import { createRedirectsFromAstroRoutes } from "@astrojs/underscore-redirects";
import esbuild from "esbuild";
import fs from "node:fs";
import npath from "node:path";
import { fileURLToPath } from "node:url";
const DENO_SHIM = `globalThis.process = {
	argv: [],
	env: Deno.env.toObject(),
};`;
async function createRedirects(config, routeToDynamicTargetMap, dir) {
  const _redirectsURL = new URL("./_redirects", dir);
  const _redirects = createRedirectsFromAstroRoutes({
    config,
    routeToDynamicTargetMap,
    dir
  });
  const content = _redirects.print();
  await fs.promises.appendFile(_redirectsURL, content, "utf-8");
}
async function createEdgeManifest(routes, entryFile, dir) {
  const functions = [];
  for (const route of routes) {
    if (route.pathname) {
      functions.push({
        function: entryFile,
        path: route.pathname
      });
    } else {
      functions.push({
        function: entryFile,
        // Make route pattern serializable to match expected
        // Netlify Edge validation format. Mirrors Netlify's own edge bundler:
        // https://github.com/netlify/edge-bundler/blob/main/src/manifest.ts#L34
        pattern: route.pattern.source.replace(/\\\//g, "/").toString()
      });
    }
  }
  const manifest = {
    functions,
    version: 1
  };
  const baseDir = new URL("./.netlify/edge-functions/", dir);
  await fs.promises.mkdir(baseDir, { recursive: true });
  const manifestURL = new URL("./manifest.json", baseDir);
  const _manifest = JSON.stringify(manifest, null, "  ");
  await fs.promises.writeFile(manifestURL, _manifest, "utf-8");
}
async function bundleServerEntry(entryUrl, serverUrl, vite) {
  var _a, _b, _c;
  const pth = fileURLToPath(entryUrl);
  await esbuild.build({
    target: "es2020",
    platform: "browser",
    entryPoints: [pth],
    outfile: pth,
    allowOverwrite: true,
    format: "esm",
    bundle: true,
    external: ["@astrojs/markdown-remark", "astro/middleware"],
    banner: {
      js: DENO_SHIM
    }
  });
  if (vite && serverUrl) {
    try {
      const chunkFileNames = ((_c = (_b = (_a = vite == null ? void 0 : vite.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.output) == null ? void 0 : _c.chunkFileNames) ?? `chunks/chunk.[hash].mjs`;
      const chunkPath = npath.dirname(chunkFileNames);
      const chunksDirUrl = new URL(chunkPath + "/", serverUrl);
      await fs.promises.rm(chunksDirUrl, { recursive: true, force: true });
    } catch {
    }
  }
}
export {
  DENO_SHIM,
  bundleServerEntry,
  createEdgeManifest,
  createRedirects
};

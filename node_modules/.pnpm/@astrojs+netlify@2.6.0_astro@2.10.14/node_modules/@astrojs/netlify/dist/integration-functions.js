import { extname } from "node:path";
import { fileURLToPath } from "node:url";
import { generateEdgeMiddleware } from "./middleware.js";
import { createRedirects } from "./shared.js";
const NETLIFY_EDGE_MIDDLEWARE_FILE = "netlify-edge-middleware";
const ASTRO_LOCALS_HEADER = "x-astro-locals";
function getAdapter(args = {}) {
  return {
    name: "@astrojs/netlify/functions",
    serverEntrypoint: "@astrojs/netlify/netlify-functions.js",
    exports: ["handler"],
    args
  };
}
function netlifyFunctions({
  dist,
  builders,
  binaryMediaTypes
} = {}) {
  let _config;
  let _entryPoints;
  let ssrEntryFile;
  let _middlewareEntryPoint;
  return {
    name: "@astrojs/netlify",
    hooks: {
      "astro:config:setup": ({ config, updateConfig }) => {
        const outDir = dist ?? new URL("./dist/", config.root);
        updateConfig({
          outDir,
          build: {
            redirects: false,
            client: outDir,
            server: new URL("./.netlify/functions-internal/", config.root)
          }
        });
      },
      "astro:build:ssr": async ({ entryPoints, middlewareEntryPoint }) => {
        if (middlewareEntryPoint) {
          _middlewareEntryPoint = middlewareEntryPoint;
        }
        _entryPoints = entryPoints;
      },
      "astro:config:done": ({ config, setAdapter }) => {
        setAdapter(getAdapter({ binaryMediaTypes, builders }));
        _config = config;
        ssrEntryFile = config.build.serverEntry.replace(/\.m?js/, "");
        if (config.output === "static") {
          console.warn(
            `[@astrojs/netlify] \`output: "server"\` or \`output: "hybrid"\` is required to use this adapter.`
          );
          console.warn(
            `[@astrojs/netlify] Otherwise, this adapter is not required to deploy a static site to Netlify.`
          );
        }
      },
      "astro:build:done": async ({ routes, dir }) => {
        const type = builders ? "builders" : "functions";
        const kind = type ?? "functions";
        if (_entryPoints.size) {
          const routeToDynamicTargetMap = /* @__PURE__ */ new Map();
          for (const [route, entryFile] of _entryPoints) {
            const wholeFileUrl = fileURLToPath(entryFile);
            const extension = extname(wholeFileUrl);
            const relative = wholeFileUrl.replace(fileURLToPath(_config.build.server), "").replace(extension, "").replaceAll("\\", "/");
            const dynamicTarget = `/.netlify/${kind}/${relative}`;
            routeToDynamicTargetMap.set(route, dynamicTarget);
          }
          await createRedirects(_config, routeToDynamicTargetMap, dir);
        } else {
          const dynamicTarget = `/.netlify/${kind}/${ssrEntryFile}`;
          const map = routes.map((route) => {
            return [route, dynamicTarget];
          });
          const routeToDynamicTargetMap = new Map(Array.from(map));
          await createRedirects(_config, routeToDynamicTargetMap, dir);
        }
        if (_middlewareEntryPoint) {
          const outPath = fileURLToPath(new URL("./.netlify/edge-functions/", _config.root));
          const netlifyEdgeMiddlewareHandlerPath = new URL(
            NETLIFY_EDGE_MIDDLEWARE_FILE,
            _config.srcDir
          );
          await generateEdgeMiddleware(
            _middlewareEntryPoint,
            outPath,
            netlifyEdgeMiddlewareHandlerPath
          );
        }
      }
    }
  };
}
export {
  ASTRO_LOCALS_HEADER,
  NETLIFY_EDGE_MIDDLEWARE_FILE,
  netlifyFunctions as default,
  getAdapter,
  netlifyFunctions
};
